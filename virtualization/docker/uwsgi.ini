[uwsgi]
socket = /tmp/uwsgi.sock
chown-socket = nginx:nginx
chmod-socket = 664
# Graceful shutdown on SIGTERM, see https://github.com/unbit/uwsgi/issues/849#issuecomment-118869386
hook-master-start = unix_signal:15 gracefully_kill_them_all
env=APP_DEBUG=1

# SOURCE: https://uwsgi-docs.readthedocs.io/en/latest/Snippets.html
; ; enable the stats server on port 9191
; stats = 127.0.0.1:9191
; ; spawn 2 threads in 4 processes (concurrency level: 8)
; processes = 4
; threads = 2
; ; drop privileges
; uid = nobody
; gid = nogroup
; py-autoreload=5

#  # ----------------------------------------------------------
#  # NOTE: Borrowed from here
#  # SOURCE: https://github.com/coralproject/atoll/blob/2b62b37d3a320480264c4a0242532aad99c338ec/deploy/playbooks/roles/app/templates/uwsgi.ini
#  # enable master process manager
#  master = true
#
#  # force full loading of the application
#  # in each worker process, after forking.
#  # forking typically loads the application,
#  # then copies it for each process. this is
#  # problematic, for instance, when connecting with
#  # databases since you have multiple processes
#  # sharing the same connection which breaks things.
#  lazy = true
#  lazy-apps = true
#
#  # spawn 2 uWSGI worker processes
#  processes = 2
#
#  # automatically kill workers on master's death
#  no-orphans = true
#
#  # place timestamps into log
#  log-date = true
#
#  # user identifier of uWSGI processes
#  uid = {{ web_group }}
#
#  # group identifier of uWSGI processes
#  gid = {{ web_group }}
#  # ----------------------------------------------------------

# enable-threads = true
#
# vaccum = true
#
# die-on-term = true
# # WSGI module and callable
# module = [wsgi_module_name]:[application_callable_name]
# module = app:app
